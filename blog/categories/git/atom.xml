<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | Blog 1]]></title>
  <link href="https://vincenttam.github.io/blog/categories/git/atom.xml" rel="self"/>
  <link href="https://vincenttam.github.io/"/>
  <updated>2015-08-07T23:27:52+08:00</updated>
  <id>https://vincenttam.github.io/</id>
  <author>
    <name><![CDATA[Vincent Tam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
      <title type="html"><![CDATA[Git Object ID Generation (3): Trees With Multiple Blobs]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-3-trees-with-multiple-blobs/"/>
    
    <updated>2015-08-07T22:30:55+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-3-trees-with-multiple-blobs</id>
    
      <content type="html"><![CDATA[<h2 id="background">Background</h2>

<p>Having written <a href="/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/">the second post</a> in this series, I thought that
I understood how to compute the SHA-1 hash of Git tree objects.</p>

<h2 id="problem">Problem</h2>

<p>Suppose that I add a file named <code>rose</code> which consisted merely of the
word <code>sweet</code> and a line terminator to the folder <code>hello</code> in
<a href="/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/">the second post</a> in this series.  I include the setup here for
convenience.</p>

<pre class="cliUB"><code>$ mkdir hello &amp;&amp; cd hello
$ git init
$ echo "hello world" &gt; hello.txt
$ git add hello.txt
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ echo "sweet" &gt; rose
$ git add rose
$ git write-tree
b12767ff2f8a8160bca15abfb775bca5ba31ccf1
$ git cat-file -p b12767ff2f8a8160bca15abfb775bca5ba31ccf1 | tee test.txt
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt
100644 blob aa823728ea7d592acc69b36875a482cdf3fd5c8d    rose
</code></pre>

<p>Therefore, our target hash is
<code>b12767ff2f8a8160bca15abfb775bca5ba31ccf1</code>.</p>

<p>Just like what I’d done in the previous post, I manually changed the
hashes into a <code>printf</code> command that writes out the binary value of the
hashes.</p>

<pre class="cliUB"><code># Note: I *didn't* type enter in the following command.  Just keep typing.
$ printf "tree 70\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4c\x83\x0
0\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad\n100644 rose\x00\xaa\x82\x37\x28\xea\x
7d\x59\x2a\xcc\x69\xb3\x68\x75\xa4\x82\xcd\xf3\xfd\x5c\x8d" | shasum
a4b430f9da3e22c0854fb26c97da77db271e5acf  -
</code></pre>

<p>What I got is <code>a4b430f9da3e22c0854fb26c97da77db271e5acf</code>, which is
<em>different</em> from the target.  <em>How can I get back <strong>the right SHA-1
hash</strong>?</em></p>

<!-- more -->

<h2 id="method">Method</h2>

<p>I read domegetter’s comment on <a href="https://gist.github.com/masak/2415865">this Gist</a>, and removed the
newline character <code>\n</code> in the middle of the quoted string in the above
<code>printf</code> command.  Then I decreased the object size by one since a
character had been taken out.</p>

<pre class="cliUB"><code># Note: I *didn't* type enter in the following command.  Just keep typing.
$ printf "tree 69\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4c\x83\x0
0\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad100644 rose\x00\xaa\x82\x37\x28\xea\x7d
\x59\x2a\xcc\x69\xb3\x68\x75\xa4\x82\xcd\xf3\xfd\x5c\x8d" | shasum
b12767ff2f8a8160bca15abfb775bca5ba31ccf1  -
</code></pre>

<p>We’re done!</p>

]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[Git Object ID Generation (2): Trees With One Single Blob]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/"/>
    
    <updated>2015-08-07T19:36:21+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob</id>
    
      <content type="html"><![CDATA[<h2 id="background">Background</h2>

<p>In <a href="/blog/2015/08/07/git-object-id-generation-1-blobs-and-commits/">the first post</a> in this series, I’ve claimed that the
generation of object IDs in Git is the SHA-1 hash of the string</p>

<pre><code>&lt;object type name&gt; SP &lt;len&gt; NUL &lt;data&gt;
</code></pre>

<p>,where</p>

<ul>
  <li><code>&lt;data&gt;</code> stands for the output of <code>git cat-file -p {hash}</code></li>
  <li><code>&lt;len&gt;</code> means the length of <code>&lt;data&gt;</code>.  It can be measured with the
  command <code>wc -c</code>.</li>
</ul>

<h2 id="problem">Problem</h2>

<p>To verify my claim, I followed the steps in Chapter 4 of <em>Version
Control with Git</em>.</p>

<ol>
  <li>Create a folder named <code>hello</code> and go to that directory.</li>
  <li>Initialise an empty Git repository.</li>
  <li>Create the file <code>hello.txt</code> with one single line “hello world”.</li>
  <li>Add the file to Git’s object storage.</li>
  <li>Get a tree object from the index.</li>
  <li>Capture the contents of the tree object in <code>test.txt</code>.</li>
  <li>Count the number of bytes in <code>test.txt</code>.</li>
  <li>
    <p>Create the file <code>len.txt</code> consisting of</p>

    <pre class="cliUB"><code> "tree" SP &lt;result in item 6&gt; NUL
</code></pre>

    <p><em>without</em> the line terminator.</p>
  </li>
  <li>Concatenate the contents of the files <code>len.txt</code> and <code>test.txt</code> and
compute its SHA-1 hash.</li>
</ol>

<pre class="cliUB"><code>$ mkdir hello &amp;&amp; cd hello
$ git init
$ echo "hello world" &gt; hello.txt
$ git add hello.txt
$ git write-tree
<span class="UBHLCode">68aba62e560c0ebc3396e8ae9335232cd93a3f60</span>
$ git cat-file -p 68aba62e560c0ebc3396e8ae9335232cd93a3f60 | tee test.txt
<span class="UBHLCode">100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad	hello.txt</span>
$ wc -c test.txt
63 test.txt
$ printf "tree 63\0" &gt; len.txt
$ cat len.txt test.txt | shasum
<span class="err">10bd0f0350027c25edc4ce72aba60e641f55596d  -</span>
</code></pre>

<p>As can be seen above, I’ve <span class="err">a wrong SHA-1
hash</span>.  <em>How can I get back <strong>the right SHA-1 hash</strong>?</em></p>

<!-- more -->

<h2 id="method">Method</h2>

<p>I googled “git tree hash id”, and I found the chosen answer of
<a href="http://stackoverflow.com/a/13977017">this Stack Overflow question</a> very explanative.  One may
shorten the included command by replacing <code>echo -en</code> with <code>printf</code>.</p>

<h3 id="get-the-object-size-right">Get the object size right</h3>

<p>In this case, the object size of the tree
<code>68aba62e560c0ebc3396e8ae9335232cd93a3f60</code> containg the blob
<code>3b18e512dba79e4c8300dd08aeb37f8e728b8dad</code> which corresponds to the
file <code>hello.txt</code> should be 37 (= 6 + 1 + 9 + 1 + 20).</p>

<h3 id="get-the-object-content-right">Get the object content right</h3>

<p>As the blob ID is stored as binary value, I copied it and pasted it
Vim so that I could easily insert <code>\x</code> in front of a pair of hex
digits in the blob ID.  I then put the things together in a command.</p>

<pre class="cliUB"><code># Contents of `testing.sh' as seen inside Vim
# Note that there's NO newline character in the following command
printf "tree 37\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4
c\x83\x00\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad" | shasum
</code></pre>

<h3 id="result">Result</h3>

<p>By executing the above command, I got <strong>the right SHA-1 hash</strong>:
<code>68aba62e560c0ebc3396e8ae9335232cd93a3f60</code>.</p>

<h2 id="fact-learnt-formatting-printfs-output">Fact learnt: formatting printf’s output</h2>

<p>In the Stack Overflow question, there’s a command</p>

<pre><code>find .git/objects/ -type f -printf "%h%f %s\n" {.cliUB}
</code></pre>

<ul>
  <li>The flag <code>-type f</code> stands for files.  <em>Without</em> this flag,
  directories like <code>.git/objects</code> will be displayed.</li>
  <li>The flag <code>-printf</code> formats the output.
    <ul>
      <li><code>%h</code> means the head of the file name <em>without</em> the last
  component of the file name.  Thus, it expands to a the path of
  a directory <em>without</em> the trailing <code>/</code>.</li>
      <li><code>%f</code> means the last component of the file name.  As a result,
  the <code>/</code> inside the displayed SHA-1 hashes are taken away.</li>
      <li><code>%s</code> means the file size</li>
    </ul>
  </li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[How Does Git Commit Amend Work?]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/how-does-git-commit-amend-work/"/>
    
    <updated>2015-08-07T17:15:29+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/how-does-git-commit-amend-work</id>
    
      <content type="html"><![CDATA[<h2 id="situation">Situation</h2>

<p>I’ve written and commited the post <a href="/blog/2015/08/06/my-git-command-list-3/"><em>My Git Command List (3)</em></a>,
but after a while, I changed that post.  In order not to complexify
my Git commit history, I used <code>git commit --amend -a</code>.  That’s quite
simple and convenient.  I observed that the displayed time in the
amended commit was the <em>same</em> as the original one, whereas the SHA-1
hash was <em>changed</em> so that Git knows that they’re <em>different</em>.
However, from
<a href="/blog/2015/08/07/git-object-id-generation-1-blobs-and-commits/"><em>Git Object ID Generation (1): Blobs and Commits</em></a>, I’ve learnt
that the ID of Git commit objects is totally determined by</p>

<ol>
  <li>the content of the commit message</li>
  <li>the commit time</li>
  <li>the author</li>
</ol>

<p>In this case, no difference of the above factors between the original
commit and the amended commit can be observed with <code>git show</code>.</p>

<h2 id="problem">Problem</h2>

<p><strong>In what way do the original commit and the amended commit differ?</strong></p>

<!-- more -->

<h2 id="difference">Difference</h2>

<p>To solve this problem, I scrolled up the screen and captured the SHA-1
hashes fo the two commits.</p>

<ul>
  <li>the original commit’s hash: <code>9de8974b93a2e4032b608c0de17ea5ed0c55524b</code></li>
  <li>the amended commit’s hash: <code>5b7b566b8a07d4813ba9f08a326e169cf38ca20f</code></li>
</ul>

<p>Note: I just <em>make up</em> the email address <code>demo@example.com</code> to replace
my real email address to <a href="http://www.problogger.net/archives/2008/12/06/10-reasons-to-avoid-mailto-links/">avoid email spams</a>.  Therefore,
<strong>the above commit hashes don’t correspond to the content displayed
below</strong>.  In fact, they correspond to the commits in the Git
repository for this blog.</p>

<pre class="cliUB"><code>$ git cat-file -p 9de8974b93a2e4032b608c0de17ea5ed0c55524b
tree b9f4fb708327e25c8b1b822711ec7dda9c5b2198
parent <a href="https://github.com/VincentTam/vincenttam.github.io/commit/afcb4d97cb447112bd2e930159966d92b8e4754a">afcb4d97cb447112bd2e930159966d92b8e4754a</a>
author Vincent Tam &lt;demo@example.com&gt; 1438859683 +0800
committer Vincent Tam &lt;demo@example.com&gt; <span class="UBHLCode">1438859683</span> +0800

A new post on some Git low level commands

I *don't* go over the details of the book *Pro Git*, which is available
online.  I just select some important ones for quick reference.
$ git cat-file -p 5b7b566b8a07d4813ba9f08a326e169cf38ca20f
tree 2d864bcb7e4944e9d98b663649c79084692873c1
parent <a href="https://github.com/VincentTam/vincenttam.github.io/commit/afcb4d97cb447112bd2e930159966d92b8e4754a">afcb4d97cb447112bd2e930159966d92b8e4754a</a>
author Vincent Tam &lt;demo@example.com&gt; 1438859683 +0800
committer Vincent Tam &lt;demo@example.com&gt; 1438864942 +0800

A new post on some Git low level commands

I *don't* go over the details of the book *Pro Git*, which is available
online.  I just select some important ones for quick reference.</code>
</pre>

<p>Hence, the difference of the timestamp of the <code>committer</code> causes the
difference in the hashes, whereas the timestamp of the <code>author</code> is
converted to a human readable date for display.</p>

<h2 id="facts-learnt">Facts learnt</h2>

<h3 id="unix-timestamp">Unix timestamp</h3>

<p>A Unix timestamp is the number of seconds elasped since the start of
the year 1970 in <abbr title="Global Mean Time">GMT</abbr>.</p>

<h3 id="a-little-bit-kramdown-syntax-eob-marker">A little bit kramdown syntax: <abbr title="End-Of-Block">EOB</abbr> marker</h3>

<p>According to kramdown’s syntax guide,
<a href="http://kramdown.gettalong.org/syntax.html#eob-marker">the <abbr title="End-Of-Block">EOB</abbr> marker <em>won’t</em> be found in most Markdown documents</a>.  In
order to include a list followed by a code block that <em>isn’t</em>
contained inside the list, the boundary of the list has to be
specified by a line consisting of a leading ‘^’ character.</p>

]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[Git Object ID Generation (1): Blobs and Commits]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-1-blobs-and-commits/"/>
    
    <updated>2015-08-07T13:52:47+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-1-blobs-and-commits</id>
    
      <content type="html"><![CDATA[<p>The SHA-1 hash for blobs <em>isn’t</em> so hard to generate, and the process
is now well-known.  I <em>don’t</em> repeat it here.  The one for commits can
be similarly generated.</p>

<!-- more -->

<p>For example, <code>5b7b566b8a07d4813ba9f08a326e169cf38ca20f</code> is a hash of
the repository of this blog.</p>

<pre class="cliUB"><code>$ git rev-parse HEAD
5b7b566b8a07d4813ba9f08a326e169cf38ca20f
$ git cat-file -p 5b7b566b8a07d4813ba9f08a326e169cf38ca20f | tee test.txt
tree 2d864bcb7e4944e9d98b663649c79084692873c1
parent afcb4d97cb447112bd2e930159966d92b8e4754a
author Vincent Tam &lt;sere@live.hk&gt; 1438859683 +0800
committer Vincent Tam &lt;sere@live.hk&gt; 1438864942 +0800

A new post on some Git low level commands

I *don't* go over the details of the book *Pro Git*, which is available
online.  I just select some important ones for quick reference.
$ wc -c test.txt
379 test.txt
$ printf "commit 379\0" &gt; len.txt
$ cat len.txt test.txt | shasum
5b7b566b8a07d4813ba9f08a326e169cf38ca20f  -
</code></pre>

<p>We get the <em>same</em> SHA-1 hash.  Therefore, the ID for Git commit
objects is just the SHA-1 hash of the contents of the Git commits with
the string <code>commit {len}\0</code> inserted at the beginning, where <code>{len}</code>
stands for the number of bytes of the Git commit object (which is
stored in <code>test.txt</code> in the above situation).</p>

<h2 id="facts-learnt">Facts learnt</h2>

<h3 id="the-printf-command">The printf command</h3>

<p>The commands <code>printf "\0"</code> and <code>printf "\000"</code> <em>doesn’t</em> differ.
Therefore, if a digit zero follows the null character, one may
indicate the null character using hex digits: <code>printf "\x000"</code>.
<code>printf</code> will interpret <code>\x00</code> as a null character and the trailing
digit <code>0</code> <em>won’t</em> be mixed up with the characters on its left.</p>

<h3 id="the-wc-command">The wc command</h3>

<p>Apart from counting words, the <code>wc</code> command provide various flags
which return the number of lines, characters, etc.  In the past, I
knew three flags only: <code>-l</code>, <code>-w</code>, and <code>-c</code>.  I thought that they told
<code>wc</code> to count the number of <strong>l</strong>ines, <strong>w</strong>ords and <strong>c</strong>haracters
respectively.  After running the <code>wc</code> command on strings that include
accents (e.g. “café”, “resumé”, etc), I realised that I misunderstood
the function of the <code>-c</code> flag, which actually counts the number of
<em>bytes</em> of the input.  To count the number of characters, use the <code>-m</code>
flag instead.</p>
]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[My Git Command List (3)]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/06/my-git-command-list-3/"/>
    
    <updated>2015-08-06T17:39:08+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/06/my-git-command-list-3</id>
    
      <content type="html"><![CDATA[<h2 id="overview">Overview</h2>

<p>Unlike the Git commands found on the previous posts in this series, in
this article, I’ll focus on <em>low-level</em> Git commands.</p>

<h2 id="raison-dtre">Raison d’être</h2>

<p>Usually, one <em>won’t</em> use low-level Git commands in a Git repository,
but I included them here because these commands help one understand
the <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">Git object model</a>.</p>

<h2 id="the-list">The list</h2>

<pre class="cliUB"><code>$ find .git/objects       # Return all files/folders under `.git/objects'
$ git cat-file -p {hash}  # Print the content to which {hash} corresponds
$ git hash-object {file}  # Return the hash of {file}
$ git hash-object --stdin # Return the hash of the standard input
$ git write-tree          # Return the hash of the tree of tracked contents
$ git ls-files -s         # List all tracked files and their hash
$ git ls-tree {hash}      # List the contents of a tree
$ git rev-parse {hash}    # Return the full SHA-1 of {hash}
$ git rev-parse HEAD      # Return the full SHA-1 of HEAD
$ git diff                # Show changes in tracked files not staged for commit
$ git diff --cached       # Show changes in tracked files staged for commit
</code></pre>

<p>It <em>isn’t</em> necessary to supply the full SHA-1 hash for
<code>{hash}</code>—several hex digits at the beginning will be enough.</p>

<h2 id="facts-learnt">Facts learnt</h2>

<ol>
  <li>An SHA-1 hash has 160 bits.  Since 1 byte is equal 8 bit, it has 20
bytes.  When it’s displayed, it has 40 hex-digits.</li>
  <li><em>The blob for a file is independent of the file name</em>, which was
actually stored in a tree object.  For example, the object ID of a
file which contains only a single line “hello world” is
<code>3b18e512dba79e4c8300dd08aeb37f8e728b8dad</code>, so if the file is stored
inside the <code>.git</code> directory as a blob, the blob will be named as
<code>.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad</code>.</li>
  <li>If a sub-directory is created in the <code>dir</code> directory, then a <code>tree</code>
entry will be created in the tree object corresponding to
<code>dir</code>.<sup id="fnref:tree_obj"><a href="#fn:tree_obj" class="footnote">1</a></sup></li>
</ol>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:tree_obj">

      <p>See the code blocks and the picture in “<a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects#Tree-Objects">Tree Objects</a>”
in Section 10.2 “Git Objects” of <em>Pro Git</em> a concrete example of a
<code>tree</code> entry inside a tree object. <a href="#fnref:tree_obj" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
    
  </entry>
  
</feed>
