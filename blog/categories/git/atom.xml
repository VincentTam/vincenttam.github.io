<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | Blog 1]]></title>
  <link href="https://vincenttam.github.io/blog/categories/git/atom.xml" rel="self"/>
  <link href="https://vincenttam.github.io/"/>
  <updated>2015-08-13T00:48:50+08:00</updated>
  <id>https://vincenttam.github.io/</id>
  <author>
    <name><![CDATA[Vincent Tam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
      <title type="html"><![CDATA[Git Object ID Generation (5): Predict ID]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/11/git-object-id-generation-5-predict-id/"/>
    
    <updated>2015-08-11T10:52:56+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/11/git-object-id-generation-5-predict-id</id>
    
      <content type="html"><![CDATA[<h2 id="goal">Goal</h2>

<p>The method for getting the Git object ID described in
<a href="/blog/2015/08/07/git-object-id-generation-4-general-trees/">previous post in this series</a> <em>isn’t</em> quick enough since it
consists of <em>several</em> commands.</p>

<h2 id="the-one-line-command">The one-line command</h2>

<h3 id="objects-with-known-git-id">Objects with known Git ID</h3>

<pre class="cliUB"><code>$ (printf "{obj_type} $(git cat-file -s {hash})\0" &amp;&amp; git cat-file {obj_type} {h
ash}) | shasum
</code></pre>

<ul>
  <li><code>{obj_type}</code> can be <code>blob</code>, <code>tree</code>, <code>commit</code> or <code>tag</code>.</li>
  <li><code>{hash}</code> is the SHA-1 hash of the object.</li>
</ul>

<p>Then the output SHA-1 hash should be the <em>same</em> as the input <code>{hash}</code>.</p>

<h3 id="predict-git-object-ids">Predict Git object IDs</h3>
<p>Hence, we can modify the above command to predict the Git object ID of
a <code>{file}</code>.</p>

<pre class="cliUB"><code>$ (printf "{obj_type} $(wc -c {file} | tr -dc '0-9')\0" &amp;&amp; cat {file}) | shasum
</code></pre>

<p>In order to verify the result for files, one can quickly get the blob
ID from Git by <code>git log -1 -p -- {file}</code>.</p>

<h2 id="facts-learnt">Facts learnt</h2>

<h2 id="extract-numbers-from-a-string-in-bash">Extract numbers from a string in bash</h2>

<p>I typed “linux extract number” on Google, and the autocompletion gave
me “from string”.  I finally saw two commands for doing this.</p>

<ol>
  <li><code>sed 's/[^0-9]//g'</code></li>
  <li><code>tr -dc '0-9'</code></li>
</ol>

<p>In my opinion, the later is simpler.  The <code>-c</code> flag takes the
complement of the characters marked by <code>-d</code>.</p>

<h3 id="using-cat-on-m-win">Using cat on M$ Win*</h3>

<p>Using the command in the section “Predict Git object IDs” gives users
a <em>wrong</em> SHA-1 sum.  The reason is that M$ Win* uses <code>\r\n</code> instead
of <code>\n</code> for starting newlines.  This also results in the <em>incorrect</em>
byte count of the files with <code>\r\n</code> as the line terminator in that
command.  Thus, the extra <code>\r</code> needs to be deleted with <code>tr -d '\r'</code>.</p>

<h3 id="using-git-for-win">Using Git for Win*</h3>

<p>For the installed version of Git on M$ Win*, one needs to use
<code>sha1sum</code> instead of <code>shasum</code>.  Otherwise, Git Bash will complain that
it is “Unable to find Digest::SHA or Digest::SHA::PurePerl”.</p>

<h3 id="using-gitportable-on-m-win">Using GitPortable on M$ Win*</h3>

<p>Since one <em>can’t</em> even issue the command <code>sha1sum</code>, use <code>openssl sha1</code>
instead.  (Omitting the trailing <code>1</code> will result in a <em>very different</em>
hexadecimal number.)</p>

]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[Git Object ID Generation (4): General Trees]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-4-general-trees/"/>
    
    <updated>2015-08-07T23:41:40+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-4-general-trees</id>
    
      <content type="html"><![CDATA[<h2 id="background">Background</h2>

<p>After I’ve written <a href="/blog/2015/08/07/git-object-id-generation-3-trees-with-multiple-blobs/">the third post</a> in this series, I believed
that I could generate the SHA-1 hash of <em>all</em> Git objects.</p>

<h2 id="problem">Problem</h2>

<p>In order to understand the object ID of an arbitrary tree object, it
is necessary that I create a file in a sub-folder.  Suppose that I
copied the file <code>hello.txt</code> to the sub-directory <code>subdir</code> in the
directory <code>hello</code> in <a href="/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/">the second post</a>  In short, I just
followed the steps in Chapter 4 of <em>Version Control with Git</em>.  I
include the setup here for convenience.</p>

<pre class="cliUB"><code>$ mkdir hello &amp;&amp; cd hello
$ git init
$ echo "hello world" &gt; hello.txt
$ git add hello.txt
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ mkdir subdir
$ cp hello.txt subdir
$ git add subdir/hello.txt
$ git write-tree
492413269336d21fac079d4a4672e55d5d2147ac
$ git cat-file -p 492413269336d21fac079d4a4672e55d5d2147ac
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad	hello.txt
040000 tree 68aba62e560c0ebc3396e8ae9335232cd93a3f60	subdir
</code></pre>

<p>After having successfully generated the SHA-1 hash for the tree object
<code>68aba62e560c0ebc3396e8ae9335232cd93a3f60</code> in <a href="/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/">the second post</a>
in this series, I tried the same task for another tree object
<code>492413269336d21fac079d4a4672e55d5d2147ac</code>.  Using the <em>same</em>
technique describe in <a href="/blog/2015/08/07/git-object-id-generation-3-trees-with-multiple-blobs/">the previous post</a>, I got another
<em>wrong</em> SHA-1 hash <code>06eb95bda67a8f86e65bb1590744f10a61eeccef</code>.</p>

<pre class="cliUB"><code># Note: I *didn't* type enter in the following command.  Just keep typing.
$ printf "tree 71\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4c\x83\x0
0\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad040000 subdir\x00\x68\xab\xa6\x2e\x56\x
0c\x0e\xbc\x33\x96\xe8\xae\x93\x35\x23\x2c\xd9\x3a\x3f\x60"
06eb95bda67a8f86e65bb1590744f10a61eeccef  -
</code></pre>

<p><em>How to get the <strong>right object ID</strong></em>?</p>

<!-- more -->

<h2 id="cause-of-error">Cause of error</h2>

<p>I realised that I had misunderstood the structure of a tree object
again after reading the first Google search result of “git tree object
format”.  It’s a Stack Overflow question on the “format of Git tree
object”.  I read the largest code block of
<a href="http://stackoverflow.com/a/21599232">the first answer</a>, and find out that <em>the leftmost zero
digit in</em> <code>040000</code> <em>should be taken away</em>.</p>

<h2 id="a-primitive-method">A primitive method</h2>

<h3 id="get-the-object-size-with-the-wc-command">Get the object size with the wc command</h3>

<pre class="cliUB"><code>$ printf "100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4c\x83\x00\xdd\x08\x
ae\xb3\x7f\x8e\x72\x8b\x8d\xad40000 subdir\x00\x68\xab\xa6\x2e\x56\x0c\x0e\xbc\x
33\x96\xe8\xae\x93\x35\x23\x2c\xd9\x3a\x3f\x60" | wc -c
70
</code></pre>

<h3 id="sha-1-hash">SHA-1 hash</h3>

<pre class="cliUB"><code>$ printf "tree 70\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4c\x83\x0
0\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad40000 subdir\x00\x68\xab\xa6\x2e\x56\x0
c\x0e\xbc\x33\x96\xe8\xae\x93\x35\x23\x2c\xd9\x3a\x3f\x60" | shasum
492413269336d21fac079d4a4672e55d5d2147ac  -
</code></pre>

<h2 id="a-more-time-saving-method">A more time-saving method</h2>

<p>The above <code>printf</code> command is error-prone.  Here’re some less
laborious commands.</p>

<h3 id="understand-the-tree-object">Understand the tree object</h3>

<p>While searching for the cause of error, I jumped through many web
pages, and I went back to
<a href="http://stackoverflow.com/a/13977017">the Stack Overflow question stated in the second post</a>
in this series.</p>

<pre class="cliUB"><code>$ git cat-file tree 492413269336d21fac079d4a4672e55d5d2147ac | od -c
0000000   1   0   0   6   4   4       h   e   l   l   o   .   t   x   t
0000020  \0   ; 030 345 022 333 247 236   L 203  \0 335  \b 256 263 177
0000040 216   r 213 215 255   4   0   0   0   0       s   u   b   d   i
0000060   r  \0   h 253 246   .   V  \f 016 274   3 226 350 256 223   5
0000100   #   , 331   :   ?   `
0000106
</code></pre>

<ul>
  <li>The <code>c</code> flag: show the input as characters if possible, otherwise as
  octal 1-byte units.</li>
  <li>The <code>b</code> flag: show the input as octal 1-byte units.</li>
</ul>

<p>Note that the number of bytes can be found at the bottom left hand
corner.  This is actually the object size of the tree object
<code>492413269336d21fac079d4a4672e55d5d2147ac</code>.</p>

<p>One can capture the binary output and dump it to <code>od</code> with one
command.</p>

<pre class="cliUB"><code>$ git cat-file tree 4924132 | tee test.txt | od -c
</code></pre>

<h3 id="an-improved-printf-command">An improved printf command</h3>

<pre class="cliUB"><code>$ printf "tree 70\0" &gt; len.txt
$ cat len.txt test.txt | shasum
492413269336d21fac079d4a4672e55d5d2147ac  -
</code></pre>

<p>We finally get the target object ID in three steps.</p>

<h2 id="facts-learnt">Facts learnt</h2>

<h3 id="another-use-of-git-cat-file">Another use of git cat-file</h3>

<pre class="cliUB"><code>$ git cat-file -s 492413269336d21fac079d4a4672e55d5d2147ac
70
</code></pre>

<ul>
  <li>The <code>-s</code> flag: size</li>
  <li>The <code>-p</code> flag: pretty-print</li>
</ul>

<p>From the word “pretty” in the man page for <code>git-cat-file</code>, I
understand why I had misunderstood the structure of Git tree objects.</p>

<h3 id="use-od-like-hd">Use od like hd</h3>

<p>From a comment to the second answer to
<a href="http://stackoverflow.com/a/21599232">the Stack Overflow question</a> about the “format of git
tree object”, I saw the word <code>hexdump</code>, and I viewed its man page.  At
first, I <em>didn’t</em> know their difference, so I googled “od vs hexdump”,
and then I saw the abbreviation <code>hd</code> for <code>hexdump</code>, so I changed the
search query string to “hd vs od”, but found out that their functions
are basically the <em>same</em>, but their display is <em>different</em> by default.
I like the default display of <code>hd</code>.  To use <code>od</code> like <code>hd</code>, one only
needs to copy the command from the man page of <code>od</code>.</p>

]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[Git Object ID Generation (3): Trees With Multiple Blobs]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-3-trees-with-multiple-blobs/"/>
    
    <updated>2015-08-07T22:30:55+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-3-trees-with-multiple-blobs</id>
    
      <content type="html"><![CDATA[<h2 id="background">Background</h2>

<p>Having written <a href="/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/">the second post</a> in this series, I thought that
I understood how to compute the SHA-1 hash of Git tree objects.</p>

<h2 id="problem">Problem</h2>

<p>Suppose that I add a file named <code>rose</code> which consisted merely of the
word <code>sweet</code> and a line terminator to the folder <code>hello</code> in
<a href="/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/">the second post</a> in this series.  I include the setup here for
convenience.</p>

<pre class="cliUB"><code>$ mkdir hello &amp;&amp; cd hello
$ git init
$ echo "hello world" &gt; hello.txt
$ git add hello.txt
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60
$ echo "sweet" &gt; rose
$ git add rose
$ git write-tree
b12767ff2f8a8160bca15abfb775bca5ba31ccf1
$ git cat-file -p b12767ff2f8a8160bca15abfb775bca5ba31ccf1 | tee test.txt
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt
100644 blob aa823728ea7d592acc69b36875a482cdf3fd5c8d    rose
</code></pre>

<p>Therefore, our target hash is
<code>b12767ff2f8a8160bca15abfb775bca5ba31ccf1</code>.</p>

<p>Just like what I’d done in the previous post, I manually changed the
hashes into a <code>printf</code> command that writes out the binary value of the
hashes.</p>

<pre class="cliUB"><code># Note: I *didn't* type enter in the following command.  Just keep typing.
$ printf "tree 70\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4c\x83\x0
0\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad\n100644 rose\x00\xaa\x82\x37\x28\xea\x
7d\x59\x2a\xcc\x69\xb3\x68\x75\xa4\x82\xcd\xf3\xfd\x5c\x8d" | shasum
a4b430f9da3e22c0854fb26c97da77db271e5acf  -
</code></pre>

<p>What I got is <code>a4b430f9da3e22c0854fb26c97da77db271e5acf</code>, which is
<em>different</em> from the target.  <em>How can I get back <strong>the right SHA-1
hash</strong>?</em></p>

<!-- more -->

<h2 id="method">Method</h2>

<p>I read domegetter’s comment on <a href="https://gist.github.com/masak/2415865">this Gist</a>, and removed the
newline character <code>\n</code> in the middle of the quoted string in the above
<code>printf</code> command.  Then I decreased the object size by one since a
character had been taken out.</p>

<pre class="cliUB"><code># Note: I *didn't* type enter in the following command.  Just keep typing.
$ printf "tree 69\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4c\x83\x0
0\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad100644 rose\x00\xaa\x82\x37\x28\xea\x7d
\x59\x2a\xcc\x69\xb3\x68\x75\xa4\x82\xcd\xf3\xfd\x5c\x8d" | shasum
b12767ff2f8a8160bca15abfb775bca5ba31ccf1  -
</code></pre>

<p>We’re done!</p>

]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[Git Object ID Generation (2): Trees With One Single Blob]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob/"/>
    
    <updated>2015-08-07T19:36:21+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/git-object-id-generation-2-trees-with-one-single-blob</id>
    
      <content type="html"><![CDATA[<h2 id="background">Background</h2>

<p>In <a href="/blog/2015/08/07/git-object-id-generation-1-blobs-and-commits/">the first post</a> in this series, I’ve claimed that the
generation of object IDs in Git is the SHA-1 hash of the string</p>

<pre><code>&lt;object type name&gt; SP &lt;len&gt; NUL &lt;data&gt;
</code></pre>

<p>,where</p>

<ul>
  <li><code>&lt;data&gt;</code> stands for the output of <code>git cat-file -p {hash}</code></li>
  <li><code>&lt;len&gt;</code> means the length of <code>&lt;data&gt;</code>.  It can be measured with the
  command <code>wc -c</code>.</li>
</ul>

<h2 id="problem">Problem</h2>

<p>To verify my claim, I followed the steps in Chapter 4 of <em>Version
Control with Git</em>.</p>

<ol>
  <li>Create a folder named <code>hello</code> and go to that directory.</li>
  <li>Initialise an empty Git repository.</li>
  <li>Create the file <code>hello.txt</code> with one single line “hello world”.</li>
  <li>Add the file to Git’s object storage.</li>
  <li>Get a tree object from the index.</li>
  <li>Capture the contents of the tree object in <code>test.txt</code>.</li>
  <li>Count the number of bytes in <code>test.txt</code>.</li>
  <li>
    <p>Create the file <code>len.txt</code> consisting of</p>

    <pre class="cliUB"><code> "tree" SP &lt;result in item 6&gt; NUL
</code></pre>

    <p><em>without</em> the line terminator.</p>
  </li>
  <li>Concatenate the contents of the files <code>len.txt</code> and <code>test.txt</code> and
compute its SHA-1 hash.</li>
</ol>

<pre class="cliUB"><code>$ mkdir hello &amp;&amp; cd hello
$ git init
$ echo "hello world" &gt; hello.txt
$ git add hello.txt
$ git write-tree
<span class="UBHLCode">68aba62e560c0ebc3396e8ae9335232cd93a3f60</span>
$ git cat-file -p 68aba62e560c0ebc3396e8ae9335232cd93a3f60 | tee test.txt
<span class="UBHLCode">100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad	hello.txt</span>
$ wc -c test.txt
63 test.txt
$ printf "tree 63\0" &gt; len.txt
$ cat len.txt test.txt | shasum
<span class="err">10bd0f0350027c25edc4ce72aba60e641f55596d  -</span>
</code></pre>

<p>As can be seen above, I’ve <span class="err">a wrong SHA-1
hash</span>.  <em>How can I get back <strong>the right SHA-1 hash</strong>?</em></p>

<!-- more -->

<h2 id="method">Method</h2>

<p>I googled “git tree hash id”, and I found the chosen answer of
<a href="http://stackoverflow.com/a/13977017">this Stack Overflow question</a> very explanative.  One may
shorten the included command by replacing <code>echo -en</code> with <code>printf</code>.</p>

<h3 id="get-the-object-size-right">Get the object size right</h3>

<p>In this case, the object size of the tree
<code>68aba62e560c0ebc3396e8ae9335232cd93a3f60</code> containg the blob
<code>3b18e512dba79e4c8300dd08aeb37f8e728b8dad</code> which corresponds to the
file <code>hello.txt</code> should be 37 (= 6 + 1 + 9 + 1 + 20).</p>

<h3 id="get-the-object-content-right">Get the object content right</h3>

<p>As the blob ID is stored as binary value, I copied it and pasted it
Vim so that I could easily insert <code>\x</code> in front of a pair of hex
digits in the blob ID.  I then put the things together in a command.</p>

<pre class="cliUB"><code># Contents of `testing.sh' as seen inside Vim
# Note that there's NO newline character in the following command
printf "tree 37\x00100644 hello.txt\x00\x3b\x18\xe5\x12\xdb\xa7\x9e\x4
c\x83\x00\xdd\x08\xae\xb3\x7f\x8e\x72\x8b\x8d\xad" | shasum
</code></pre>

<h3 id="result">Result</h3>

<p>By executing the above command, I got <strong>the right SHA-1 hash</strong>:
<code>68aba62e560c0ebc3396e8ae9335232cd93a3f60</code>.</p>

<h2 id="fact-learnt-formatting-printfs-output">Fact learnt: formatting printf’s output</h2>

<p>In the Stack Overflow question, there’s a command</p>

<pre><code>find .git/objects/ -type f -printf "%h%f %s\n" {.cliUB}
</code></pre>

<ul>
  <li>The flag <code>-type f</code> stands for files.  <em>Without</em> this flag,
  directories like <code>.git/objects</code> will be displayed.</li>
  <li>The flag <code>-printf</code> formats the output.
    <ul>
      <li><code>%h</code> means the head of the file name <em>without</em> the last
  component of the file name.  Thus, it expands to a the path of
  a directory <em>without</em> the trailing <code>/</code>.</li>
      <li><code>%f</code> means the last component of the file name.  As a result,
  the <code>/</code> inside the displayed SHA-1 hashes are taken away.</li>
      <li><code>%s</code> means the file size</li>
    </ul>
  </li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
      <title type="html"><![CDATA[How Does Git Commit Amend Work?]]></title>
      <link href="https://vincenttam.github.io/blog/2015/08/07/how-does-git-commit-amend-work/"/>
    
    <updated>2015-08-07T17:15:29+08:00</updated>
    <id>https://vincenttam.github.io/blog/2015/08/07/how-does-git-commit-amend-work</id>
    
      <content type="html"><![CDATA[<h2 id="situation">Situation</h2>

<p>I’ve written and commited the post <a href="/blog/2015/08/06/my-git-command-list-3/"><em>My Git Command List (3)</em></a>,
but after a while, I changed that post.  In order not to complexify
my Git commit history, I used <code>git commit --amend -a</code>.  That’s quite
simple and convenient.  I observed that the displayed time in the
amended commit was the <em>same</em> as the original one, whereas the SHA-1
hash was <em>changed</em> so that Git knows that they’re <em>different</em>.
However, from
<a href="/blog/2015/08/07/git-object-id-generation-1-blobs-and-commits/"><em>Git Object ID Generation (1): Blobs and Commits</em></a>, I’ve learnt
that the ID of Git commit objects is totally determined by</p>

<ol>
  <li>the content of the commit message</li>
  <li>the commit time</li>
  <li>the author</li>
</ol>

<p>In this case, no difference of the above factors between the original
commit and the amended commit can be observed with <code>git show</code>.</p>

<h2 id="problem">Problem</h2>

<p><strong>In what way do the original commit and the amended commit differ?</strong></p>

<!-- more -->

<h2 id="difference">Difference</h2>

<p>To solve this problem, I scrolled up the screen and captured the SHA-1
hashes fo the two commits.</p>

<ul>
  <li>the original commit’s hash: <code>9de8974b93a2e4032b608c0de17ea5ed0c55524b</code></li>
  <li>the amended commit’s hash: <code>5b7b566b8a07d4813ba9f08a326e169cf38ca20f</code></li>
</ul>

<p>Note: I just <em>make up</em> the email address <code>demo@example.com</code> to replace
my real email address to <a href="http://www.problogger.net/archives/2008/12/06/10-reasons-to-avoid-mailto-links/">avoid email spams</a>.  Therefore,
<strong>the above commit hashes don’t correspond to the content displayed
below</strong>.  In fact, they correspond to the commits in the Git
repository for this blog.</p>

<pre class="cliUB"><code>$ git cat-file -p 9de8974b93a2e4032b608c0de17ea5ed0c55524b
tree b9f4fb708327e25c8b1b822711ec7dda9c5b2198
parent <a href="https://github.com/VincentTam/vincenttam.github.io/commit/afcb4d97cb447112bd2e930159966d92b8e4754a">afcb4d97cb447112bd2e930159966d92b8e4754a</a>
author Vincent Tam &lt;demo@example.com&gt; 1438859683 +0800
committer Vincent Tam &lt;demo@example.com&gt; <span class="UBHLCode">1438859683</span> +0800

A new post on some Git low level commands

I *don't* go over the details of the book *Pro Git*, which is available
online.  I just select some important ones for quick reference.
$ git cat-file -p 5b7b566b8a07d4813ba9f08a326e169cf38ca20f
tree 2d864bcb7e4944e9d98b663649c79084692873c1
parent <a href="https://github.com/VincentTam/vincenttam.github.io/commit/afcb4d97cb447112bd2e930159966d92b8e4754a">afcb4d97cb447112bd2e930159966d92b8e4754a</a>
author Vincent Tam &lt;demo@example.com&gt; 1438859683 +0800
committer Vincent Tam &lt;demo@example.com&gt; 1438864942 +0800

A new post on some Git low level commands

I *don't* go over the details of the book *Pro Git*, which is available
online.  I just select some important ones for quick reference.</code>
</pre>

<p>Hence, the difference of the timestamp of the <code>committer</code> causes the
difference in the hashes, whereas the timestamp of the <code>author</code> is
converted to a human readable date for display.</p>

<h2 id="facts-learnt">Facts learnt</h2>

<h3 id="unix-timestamp">Unix timestamp</h3>

<p>A Unix timestamp is the number of seconds elasped since the start of
the year 1970 in <abbr title="Global Mean Time">GMT</abbr>.</p>

<h3 id="a-little-bit-kramdown-syntax-eob-marker">A little bit kramdown syntax: <abbr title="End-Of-Block">EOB</abbr> marker</h3>

<p>According to kramdown’s syntax guide,
<a href="http://kramdown.gettalong.org/syntax.html#eob-marker">the <abbr title="End-Of-Block">EOB</abbr> marker <em>won’t</em> be found in most Markdown documents</a>.  In
order to include a list followed by a code block that <em>isn’t</em>
contained inside the list, the boundary of the list has to be
specified by a line consisting of a leading ‘^’ character.</p>

]]></content>
    
  </entry>
  
</feed>
